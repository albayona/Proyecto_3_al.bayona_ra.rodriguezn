    85: 	for (int f = 0; sizeof(a) - 1 > f; f++) //se recorre datosBin -> informacion - En cada recorrido se imprimen 3 numeros entre 0 y 7
00041AD3 C7 85 30 FF FF FF 00 00 00 00 mov         dword ptr [ebp-0D0h],0  
00041ADD EB 0F                jmp         calcularCRC+0DEh (041AEEh)  
00041ADF 8B 85 30 FF FF FF    mov         eax,dword ptr [ebp-0D0h]  
00041AE5 83 C0 01             add         eax,1  
00041AE8 89 85 30 FF FF FF    mov         dword ptr [ebp-0D0h],eax  
00041AEE 81 BD 30 FF FF FF 8A 00 00 00 cmp         dword ptr [ebp-0D0h],8Ah  
00041AF8 0F 83 97 01 00 00    jae         calcularCRC+285h (041C95h)  
    86: 	{
    87: 
    88: 		//el polinomio generador se parte en dos bytes
    89: 
    90: 		unsigned char tempDivisor1 = divisor;							 // este se utiliza para representar un polinomio con el que se aplica xor al char actual, 
00041AFE 8A 45 F7             mov         al,byte ptr [divisor]  
00041B01 88 85 27 FF FF FF    mov         byte ptr [ebp-0D9h],al  
    91: 																		//a meduda que el polinomio generador se vaya moviendo a la derecha; orginalmente es el mismo polinomio generador
    92: 
    93: 		unsigned char tempDivisor2 = 0;									 // este se utiliza para representar un polinomio que es la parte que se ha movido a la derecha del polinomio generador; 
00041B07 C6 85 1B FF FF FF 00 mov         byte ptr [ebp-0E5h],0  
    94: 																		//con el cual se aplica xor al char siguiente al actual; originalmente es 0;
    95: 
    96: 		for (size_t i = 0; i < 8; i++)									//se recorre cada bit del char (byte) actual y su contiguo
00041B0E C7 85 0C FF FF FF 00 00 00 00 mov         dword ptr [ebp-0F4h],0  
00041B18 EB 0F                jmp         calcularCRC+119h (041B29h)  
00041B1A 8B 85 0C FF FF FF    mov         eax,dword ptr [ebp-0F4h]  
00041B20 83 C0 01             add         eax,1  
00041B23 89 85 0C FF FF FF    mov         dword ptr [ebp-0F4h],eax  
00041B29 83 BD 0C FF FF FF 08 cmp         dword ptr [ebp-0F4h],8  
00041B30 0F 83 5A 01 00 00    jae         calcularCRC+280h (041C90h)  
    97: 		{
    98: 			unsigned char  tempChar = e[f];
00041B36 8B 85 54 FF FF FF    mov         eax,dword ptr [e]  
00041B3C 03 85 30 FF FF FF    add         eax,dword ptr [ebp-0D0h]  
00041B42 8A 08                mov         cl,byte ptr [eax]  
00041B44 88 8D 03 FF FF FF    mov         byte ptr [ebp-0FDh],cl  
    99: 
   100: 			unsigned char  MSB = (tempChar >> (7 - i));					// se aisla el bit mas significativo del char actual;
00041B4A 0F B6 85 03 FF FF FF movzx       eax,byte ptr [ebp-0FDh]  
00041B51 B9 07 00 00 00       mov         ecx,7  
00041B56 2B 8D 0C FF FF FF    sub         ecx,dword ptr [ebp-0F4h]  
00041B5C D3 F8                sar         eax,cl  
00041B5E 88 85 F7 FE FF FF    mov         byte ptr [ebp-109h],al  
   101: 
   102: 			if (MSB == 0) {												// si el bit mas significativo del char actual es 0 entonces no se efectua xor y se actualizan los dos polinomios auxiliares:
00041B64 0F B6 85 F7 FE FF FF movzx       eax,byte ptr [ebp-109h]  
00041B6B 85 C0                test        eax,eax  
00041B6D 75 5F                jne         calcularCRC+1BEh (041BCEh)  
   103: 
   104: 				unsigned char  LSB = (tempDivisor1 << 7);				//pasandolo al inicio de un byte, se aisla el bit menos significativo , que va formar parte del inicio del polinomio auxiliar 2
00041B6F 0F B6 85 27 FF FF FF movzx       eax,byte ptr [ebp-0D9h]  
00041B76 C1 E0 07             shl         eax,7  
00041B79 88 85 EB FE FF FF    mov         byte ptr [ebp-115h],al  
   105: 
   106: 				tempDivisor1 = tempDivisor1 >> 1;						// Se actualiza el polinomio 1 desplzandolo a la derecha 
00041B7F 0F B6 85 27 FF FF FF movzx       eax,byte ptr [ebp-0D9h]  
00041B86 D1 F8                sar         eax,1  
00041B88 88 85 27 FF FF FF    mov         byte ptr [ebp-0D9h],al  
   107: 
   108: 				if (LSB == 128) {										// Si el bit menos significativo es 1, entonces se le agrega el bit 1 al comienzo del polinomio 2
00041B8E 0F B6 85 EB FE FF FF movzx       eax,byte ptr [ebp-115h]  
00041B95 3D 80 00 00 00       cmp         eax,80h  
00041B9A 75 23                jne         calcularCRC+1AFh (041BBFh)  
   109: 					tempDivisor2 = tempDivisor2 >> 1;
00041B9C 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041BA3 D1 F8                sar         eax,1  
00041BA5 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   110: 					tempDivisor2 = tempDivisor2 + 0x80;
00041BAB 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041BB2 05 80 00 00 00       add         eax,80h  
00041BB7 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   111: 				}
   112: 				else {													// Si el bit menos significativo es 0, entonces se agrega el bit 0 al comienzo del polinomio 2
00041BBD EB 0F                jmp         calcularCRC+1BEh (041BCEh)  
   113: 					tempDivisor2 = tempDivisor2 >> 1;
00041BBF 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041BC6 D1 F8                sar         eax,1  
00041BC8 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   114: 				}
   115: 			}
   116: 
   117: 			if (MSB == 1) {												// si el bit mas significativo del char actual es 1 entonces se efectua xor y se actualizan los dos polinomios auxiliares:
00041BCE 0F B6 85 F7 FE FF FF movzx       eax,byte ptr [ebp-109h]  
00041BD5 83 F8 01             cmp         eax,1  
00041BD8 0F 85 AD 00 00 00    jne         calcularCRC+27Bh (041C8Bh)  
   118: 
   119: 				e[f] = e[f] ^ tempDivisor1; // se efectua xor con el polinomio 1 y el char actual
00041BDE 8B 85 54 FF FF FF    mov         eax,dword ptr [e]  
00041BE4 03 85 30 FF FF FF    add         eax,dword ptr [ebp-0D0h]  
00041BEA 0F B6 08             movzx       ecx,byte ptr [eax]  
00041BED 0F B6 95 27 FF FF FF movzx       edx,byte ptr [ebp-0D9h]  
00041BF4 33 CA                xor         ecx,edx  
00041BF6 8B 85 54 FF FF FF    mov         eax,dword ptr [e]  
00041BFC 03 85 30 FF FF FF    add         eax,dword ptr [ebp-0D0h]  
   118: 
   119: 				e[f] = e[f] ^ tempDivisor1; // se efectua xor con el polinomio 1 y el char actual
00041C02 88 08                mov         byte ptr [eax],cl  
   120: 
   121: 				unsigned char  LSB = (tempDivisor1 << 7);				 //pasandolo al inicio de un byte, se aisla el bit menos significativo , que va formar parte del inicio del polinomio auxiliar 2
00041C04 0F B6 85 27 FF FF FF movzx       eax,byte ptr [ebp-0D9h]  
00041C0B C1 E0 07             shl         eax,7  
00041C0E 88 85 DF FE FF FF    mov         byte ptr [ebp-121h],al  
   122: 				tempDivisor1 = tempDivisor1 >> 1;						 // Se actualiza el polinomio 1 desplzandolo a la derecha 
00041C14 0F B6 85 27 FF FF FF movzx       eax,byte ptr [ebp-0D9h]  
00041C1B D1 F8                sar         eax,1  
00041C1D 88 85 27 FF FF FF    mov         byte ptr [ebp-0D9h],al  
   123: 
   124: 				e[f + 1] = e[f + 1] ^ tempDivisor2; // se efectua xor con el polinomio 2 y el char siguiente al actual
00041C23 8B 85 54 FF FF FF    mov         eax,dword ptr [e]  
00041C29 03 85 30 FF FF FF    add         eax,dword ptr [ebp-0D0h]  
00041C2F 0F B6 48 01          movzx       ecx,byte ptr [eax+1]  
00041C33 0F B6 95 1B FF FF FF movzx       edx,byte ptr [ebp-0E5h]  
00041C3A 33 CA                xor         ecx,edx  
00041C3C 8B 85 54 FF FF FF    mov         eax,dword ptr [e]  
00041C42 03 85 30 FF FF FF    add         eax,dword ptr [ebp-0D0h]  
00041C48 88 48 01             mov         byte ptr [eax+1],cl  
   125: 
   126: 
   127: 				if (LSB == 128) {										// Si el bit menos significativo es 1, entonces se  agrega el bit 1 al comienzo del polinomio 2
00041C4B 0F B6 85 DF FE FF FF movzx       eax,byte ptr [ebp-121h]  
00041C52 3D 80 00 00 00       cmp         eax,80h  
00041C57 75 23                jne         calcularCRC+26Ch (041C7Ch)  
   128: 					tempDivisor2 = tempDivisor2 >> 1;
00041C59 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041C60 D1 F8                sar         eax,1  
00041C62 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   129: 					tempDivisor2 = tempDivisor2 + 0x80;
00041C68 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041C6F 05 80 00 00 00       add         eax,80h  
00041C74 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   130: 
   131: 				}
   132: 				else {
00041C7A EB 0F                jmp         calcularCRC+27Bh (041C8Bh)  
   133: 					tempDivisor2 = tempDivisor2 >> 1;					// Si el bit menos significativo es 0, entonces se  agrega el bit 0 al comienzo del polinomio 2
00041C7C 0F B6 85 1B FF FF FF movzx       eax,byte ptr [ebp-0E5h]  
00041C83 D1 F8                sar         eax,1  
00041C85 88 85 1B FF FF FF    mov         byte ptr [ebp-0E5h],al  
   134: 
   135: 				}
   136: 
   137: 
   138: 			}
   139: 
   140: 		}
00041C8B E9 8A FE FF FF       jmp         calcularCRC+10Ah (041B1Ah)  
   141: 
   142: 
   143: 
   144: 
   145: 	}
00041C90 E9 4A FE FF FF       jmp         calcularCRC+0CFh (041ADFh)  
   146: }